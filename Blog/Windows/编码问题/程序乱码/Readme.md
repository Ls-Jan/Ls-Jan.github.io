

要讨论这个问题，首先得说明几个概念：


#### 字节流：
由一个或连续多个字节所组成。

#### 编码：
编码得在指定的字符集下才有其含义，而字符集这玩意儿坏就坏在它是多种多样的，也就是采用哪个字符集来理解一段字节流完全取决于程序。

**编码**和**字节流**并不等价，字节流在指定字符集下才能称之为编码，当然的，有“有效编码”和“无效编码”。
不同编译器、软件乃至操作系统对“无效编码”所采取的策略都不尽相同，有可能会将其替换为方形□，也有可能替换为问号?。
当然“有效编码”只是代表它有对应字符，至于这个字符是不是正确的就是另一回事(也就是乱码)。

#### 字符串：
字符串得在指定字符集下才有意义，不然就是一坨无意义的字节流。
也就是**字符串的概念是和字符集是高度绑定的，不能分离**。
事实上也就C/C++才有这些屁事，其他语言通常早已将字符串和字节流的关系撇的一干二净。
以Python作为举例，Python的字符串``str``固定使用Unicode编码(具体使用的是UTF-8还是UTF-32则不清楚)，与字节流``bytes``没有直接联系，如果字节流``bytes``想转为``str``就必须调用``bytes.decode``，字符串的相关操作(连接、长度计算等)都是基于``str``而不是``bytes``的。
反观C/C++，由于没有明确的字符串概念，你所持有的那些以``char*``为核心的函数实际上都是基于字节流进行操作的，就非常非常的整蛊，
因此作为C/C++开发者要时刻意识到自己所持有的``char*``字符串(严格点应该说是字节流)到底是使用了哪种字符集，如果使用的是宽字符串``wchar_t*``则会少点麻烦(宽字符串以UTF-16LE编码)。

#### 编码转换：
将原字符集下的原字节流，转换为目标字符集下的字节流，用函数来描述就是``Trans(cpA,cpB,bytesA)``，接受三个参数并返回转化后的字节流。
这个转化映射关系由API提供，开发者不需要也不必要去关心这个映射的实现，只需要知道有那么一个玩意儿即可，例如winAPI提供了``MultiByteToWideChar``和``WideCharToMultiByte``实现指定编码与UTF-16LE编码之间的转换。

将日文字符集下の的编码``\x82\xCC``转换为GBK字符集下の的编码``"\xA4\xCE"``。问为什么要转换？日文字符集下の的编码``\x82\xCC``在GBK下并不代表の这个字符，甚至这个编码是否有效都不一定。

#### 乱码：
使用错误的字符集解析一段字节流，得到奇怪的字符串。
为了避免乱码，得时刻注意所获取的字节流到底对应的是哪个字符集。

<br>
<br>

## 总结：

事实上，无论使用哪种语言哪种框架进行开发，都应该：
- 确定拿到的字节流对应的是哪种字符集；
- 程序最好固定使用某一个字符集，通常是UTF-8或是UTF-16；
- 如果可能的话，不要使用ANSI编码，它能将一个简单的问题变得复杂化，并且会导致一个软件无法在另一个区域语言中顺利使用，例如通常所说的“中文软件”、“台湾软件”、“日文软件”等就是使用ANSI导致的；
- 确保源文件的编码与程序所使用的字符集是一致的，不要出现源文件用的是UTF-8而程序使用GBK进行输入输出；
- 确保源文件的编码与编译器使用的字符集是一致的，不然大概率出现乱码甚至编译失败；



# 参考：
- 细说字符集(CharSet)和字符编码(Encoding)：[https://kelvinleong.github.io/encoding/2015/09/15/Encoding-and-CharSets.html](https://kelvinleong.github.io/encoding/2015/09/15/Encoding-and-CharSets.html)




